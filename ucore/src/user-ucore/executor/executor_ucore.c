// Copyright 2015 syzkaller project authors. All rights reserved.
// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

// +build

#include <ulib.h>
#include <file.h>
#include <string.h>
#include <stat.h>
#include <syscall.h>
#include <types.h>
#include <unistd.h>
/*#include <fcntl.h>
#include <limits.h>
#include <pthread.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/time.h>
#include <sys/wait.h>*/

#define SYZ_EXECUTOR
#include "common_ucore.h"

#include "executor_ucore.h"

#include "executor.h"

#include "syscalls_ucore.h"

#define KCOV_INIT_TRACE32 _IOR('c', 1, uint32)
#define KCOV_INIT_TRACE64 _IOR('c', 1, uint64)
#define KCOV_ENABLE _IO('c', 100)
#define KCOV_DISABLE _IO('c', 101)

const unsigned long KCOV_TRACE_PC = 0;
const unsigned long KCOV_TRACE_CMP = 1;

// const int kInFd = 3;
// const int kOutFd = 4;

// The address chosen must also work on 32-bit kernels with 1GB user address space.
void* const kOutputDataAddr = (void*)0x1b2bc20000ull;

// because there's no build-in atomic operation of uint32* in C99, and we can't use atomic_t since the output_data is generated by mmap, 
// the only way to implement this is to use semaphone.
sem_t output_data_mutex ;
uint32* output_data;
uint32* output_pos;

static bool detect_kernel_bitness();

int main(int argc, char** argv) // checked
{
	fprintf(1, "executor main\n");
	output_data_mutex = sem_init(1) ;
	debug_mutex = sem_init(1);

	is_kernel_64_bit = detect_kernel_bitness();
	if (argc == 2 && strcmp(argv[1], "version") == 0) {
		cputs(GOOS " " GOARCH " " SYZ_REVISION " " GIT_REVISION);
		return 0;
	}

    //父进程一旦去世(fuzzer)，则给子进程一个SIGKILL。因为没有父进程，所以这段就不要了
	//prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);

	//用3个mmap建立内存映射，用于保存输入文件、输出文件
	//mmap函数需要重写，更改一下syscall
	//或许kernal的syscall都需要更改？checked
#define PROT_READ 0x1 
#define PROT_WRITE 0x2 
#define MAP_SHARED 0x1
#define MAP_PRIVATE 0x2
#define MAP_FIXED 0x10
#define MAP_ANON 0x20

	// if (sys_linux_mmap(&input_data[0], kMaxInput, PROT_READ, MAP_PRIVATE | MAP_FIXED, kInFd, 0) != &input_data[0])
	// 	fail("mmap of input file failed");
	// The output region is the only thing in executor process for which consistency matters.
	// If it is corrupted ipc package will fail to parse its contents and panic.
	// But fuzzer constantly invents new ways of how to currupt the region,
	// so we map the region at a (hopefully) hard to guess address surrounded by unmapped pages.
	cprintf("executor mmaping\n");
	debug("mmmaping\n");
	output_data = (uint32*)sys_linux_mmap(kOutputDataAddr, kMaxOutput,
				    PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANON, -1, 0);
	cprintf("mapping: outputdata=%llx\n", output_data) ;
	if (output_data != kOutputDataAddr)
		fail("mmap of output file failed");

	if (sys_linux_mmap((void*)SYZ_DATA_OFFSET, SYZ_NUM_PAGES * SYZ_PAGE_SIZE, PROT_READ | PROT_WRITE,
		 MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0) != (void*)SYZ_DATA_OFFSET)
		fail("mmap of data segment failed");
	debug("mmmaping finished\n");
	// Prevent random programs to mess with these fds.
	// Due to races in collider mode, a program can e.g. ftruncate one of these fds,
	// which will cause fuzzer to crash.
	// That's also the reason why we close kInPipeFd/kOutPipeFd below.
	// close(kInFd);
	// close(kOutFd);
	
	// 建立控制管道，也许需要更新
	setup_control_pipes();
	// 和fuzzer握手，需要更新
	receive_handshake();
	debug("handshake received\n");

	// 创建KCOV的cover，可以忽略
	// cover_open(); 
	// 注册处理信号的一系列sigaction
	install_segv_handler();
	// 建立工作文件夹
	use_temporary_dir();

	int pid = -1;
	// ucore没有用户组，所以采用none（可能会导致一些false positive）
	pid = do_sandbox_none(); 

	// 后面是父进程的操作, checked
	if (pid < 0)
		fail("clone failed");
	debug("spawned loop pid %d\n", pid);
	int status = 0;
	while (waitpid(-1, &status, 0) != pid) { //后面有个__WALL的选项没选，这个如果要深究的话只能看内核了。。
	}
	status = WEXITSTATUS(status);
	// Other statuses happen when fuzzer processes manages to kill loop.
	if (status != kFailStatus && status != kErrorStatus)
		status = kRetryStatus;
	// If an external sandbox process wraps executor, the out pipe will be closed
	// before the sandbox process exits this will make ipc package kill the sandbox.
	// As the result sandbox process will exit with exit status 9 instead of the executor
	// exit status (notably kRetryStatus). Consequently, ipc will treat it as hard
	// failure rather than a temporal failure. So we duplicate the exit status on the pipe.
	reply_execute(status);
	errno = 0;
	if (status == kFailStatus)
		fail("loop failed");
	if (status == kErrorStatus)
		error("loop errored");
	// Loop can be killed by a test process with e.g.:
	// ptrace(PTRACE_SEIZE, 1, 0, 0x100040)
	// This is unfortunate, but I don't have a better solution than ignoring it for now.
	exitf("loop exited with status %d", status);
	// Unreachable.
	return 1;
}

//static __thread thread_t* current_thread;

long execute_syscall(struct call_t* c, long a0, long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8) // checked
{
	if (c->call)
		return c->call(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	return syscall(c->sys_nr, a0, a1, a2, a3, a4, a5);
}

// 下面四个函数涉及到KCOV，由于ucore还没这个支持，所以先不管
void cover_open() // checked
{
	if (!flag_cover)
		return;
#ifdef SYSTEM_HAVE_KCOV
	for (int i = 0; i < kMaxThreads; i++) {
		thread_t* th = &threads[i];
		th->cover_fd = open("/sys/kernel/debug/kcov", O_RDWR);
		if (th->cover_fd == -1)
			fail("open of /sys/kernel/debug/kcov failed");
		const int kcov_init_trace = is_kernel_64_bit ? KCOV_INIT_TRACE64 : KCOV_INIT_TRACE32;
		if (ioctl(th->cover_fd, kcov_init_trace, kCoverSize))
			fail("cover init trace write failed");
		size_t mmap_alloc_size = kCoverSize * (is_kernel_64_bit ? 8 : 4);
		th->cover_data = (char*)mmap(NULL, mmap_alloc_size,
					     PROT_READ | PROT_WRITE, MAP_SHARED, th->cover_fd, 0);
		th->cover_end = th->cover_data + mmap_alloc_size;
		if (th->cover_data == MAP_FAILED)
			fail("cover mmap failed");
	}
#endif
}

void cover_enable(struct thread_t* th) // checked
{
	if (!flag_cover)
		return;
#ifdef SYSTEM_HAVE_KCOV
	debug("#%d: enabling /sys/kernel/debug/kcov\n", th->id);
	int kcov_mode = flag_collect_comps ? KCOV_TRACE_CMP : KCOV_TRACE_PC;
	// This should be fatal,
	// but in practice ioctl fails with assorted errors (9, 14, 25),
	// so we use exitf.
	if (ioctl(th->cover_fd, KCOV_ENABLE, kcov_mode))
		exitf("cover enable write trace failed, mode=%d", kcov_mode);
	debug("#%d: enabled /sys/kernel/debug/kcov\n", th->id);
	current_thread = th;
#endif
}

void cover_reset(struct thread_t* th) // checked
{
	if (!flag_cover)
		return;
#ifdef SYSTEM_HAVE_KCOV
	if (th == 0)
		th = current_thread;
	*(uint64*)th->cover_data = 0;
#endif
}

uint32 read_cover_size(struct thread_t* th) // checked
{
	if (!flag_cover)
		return 0;
#ifdef SYSTEM_HAVE_KCOV
	// Note: this assumes little-endian kernel.
	uint32 n = *(uint32*)th->cover_data;
	debug("#%d: read cover size = %u\n", th->id, n);
	if (n >= kCoverSize)
		fail("#%d: too much cover %u", th->id, n);
	return n;
#endif
}

uint32* write_output(uint32 v) // checked
{
	if (collide)
		return 0;
	if (output_pos < output_data || (char*)output_pos >= (char*)output_data + kMaxOutput)
		fail("output overflow");
	*output_pos = v;
	return output_pos++;
}

void write_completed(uint32 completed) // checked
{			
	debug("waiting for output_data_mutex...") ;
	sem_wait(output_data_mutex) ;
	*output_data = completed;
	sem_post(output_data_mutex) ;
	debug("wait ended...") ;
}

// 检查系统到底是多少位的
static bool detect_kernel_bitness() // checked
{
	if (sizeof(void*) == 8)
		return true;
	return false ;
	// 由于没有相应的文件，因此不采用下面的较为复杂的判定法。
	/*
	// It turns out to be surprisingly hard to understand if the kernel underneath is 64-bits.
	// A common method is to look at uname.machine. But it is produced in some involved ways,
	// and we will need to know about all strings it returns and in the end it can be overriden
	// during build and lie (and there are known precedents of this).
	// So instead we look at size of addresses in /proc/kallsyms.
	bool wide = true;
	int fd = open("/proc/kallsyms", O_RDONLY);
	if (fd != -1) {
		char buf[16];
		if (read(fd, buf, sizeof(buf)) == sizeof(buf) &&
		    (buf[8] == ' ' || buf[8] == '\t'))
			wide = false;
		close(fd);
	}
	debug("detected %d-bit kernel\n", wide ? 64 : 32);
	return wide;*/
}
